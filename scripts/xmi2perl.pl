#!/usr/local/bin/perl -w

# ------------------------------------------------------------------------
# Title:  xmi2perl XMI to Perl modules
#
# File - examples/xmi2perl.pl
# Version - 1.0
#
# Abstract:
#
#   xmi2perl translates XMI 2.1 files into perl modules for the Perl Test Tools.
#   XMI is standard XML format to handle UML models. 
#
#   Warning, this script use some of the proprietary XML elements generated
#   by BoUML, the free UML modeler. It propbably does not work on XMI
#   generated by other tools.
#
#   There is no reverse engineering or even update of existing code support.
#   So it is a kind of smart template generator that you can use initialy in your projects
#   to speed up the modules generation. After that you have to maintain
#   both the model and your code without merge possibility.
#
# Code generation:
#
#   Currently the code is generated on line by the script. Perhaps that the script
#   will evolve toward a more modular structure tu support other kinds of 
#   generation.
#
#   - The script generates its output in a directory named after the UML project.
#
#   - It generates a .txt file with  the comments associated to the project.
#   It is recommended to insert this comment in a format compatible with
#   NaturalDocs, that way you will get it back in the project online documentation.
#
#   - It generates one perl module for each class of the class diagram, with
#   one method for each operation.
#
#   - Comments associated to classes and methods are reported in the code.
#   It is recommended to use the NaturalDocs syntax. There is no comments
#   associated to the parameters of a method, so include the parameter
#   description in the method comment.
#
#   - Abstract methods generate an exception when called. In fact in Perl there
#   is even no needs to generate abstract methods, there is no real way to force
#   a child to implement a method and no way to forbid instaciation of
#   an abstract class. I generate something mainly for documentation.
#
#   - There is a stereotype named 'accessor'. When it is associated to a method
#   some special code is generated in the method.
#
#   - Root class includes the generation of new and _init methods (elements)
#   of the constructor and an inheritable dump method which provides a standard implementation
#   to print the contain of the object.
#
#   A least do not forget that the behavior documented above is only a possibility
#   you can easily adapt it to your needs or tastes.
#
# Usage:
# (Start code)
#xmi2perl is a script to translate XMI 2.1 files into PerlTestTools
#modules. XMI is standard XML format to handle UML models. It has not been designed
#to provide a full XML support but rather to generate quickly Perl modules from
#the subset generated by BOUML.
#
#Use the "Generate extension" option of the BoUML export tool.
#usage: perl xmi2perl.pl [options] [filenames]*
#        -verbose         flag,     switch on verbose mode.
#        -help            flag,     display the online help.
#        -outputDirectory string,   directory for outputs
#        -targetDirectory string,   Generation directories
#
# (end)
# ------------------------------------------------------------------------
package XMI2Perl;

use strict;
use lib "$ENV{'PERL_TEST_TOOLS_PATH'}/lib";
use TestTools::Script;
use XML::Twig;
use Data::Dumper;
use TestTools::Conf::ScriptConfig qw (GetOnlineHelp GetOption Load NumberOfElements Initialize);

use vars qw($VERSION @ISA @EXPORT);
use Exporter;

$VERSION = 1;
@ISA     = qw(TestTools::Script);

# This hash table is used to declare and define options.
my %OptionSet = (
    targetDirectory   =>  {
    type => "string",
    description => "Generation directories",
    default => ""
    },
);

# ########################################################################
my $targetDir = "TestTools";

my $twig = XML::Twig->new();

my $help = "
xmi2perl is a script to translate XMI 2.1 files into PerlTestTools
modules. XMI is standard XML format to handle UML models. It has not been designed
to provide a full XML support but rather to generate quickly Perl modules from
the subset generated by BOUML.

Use the \"Generate extension\" option of the BoUML export tool.
";

my $dumper = '        
# ------------------------------------------------------------------------
# method: dump
#
# print an ASCII representation of the object
# ------------------------------------------------------------------------
sub dump {
    my $Self = shift;

    print Dumper($Self), "\n";
}
';

my $constructor = '

# ------------------------------------------------------------------------
# method: new
# 
# Returns a new initialised object for the class.
# ------------------------------------------------------------------------
sub new {
  my $Class = shift;
  my $Self = {};

  bless ($Self, $Class);

  $Self->{Logger} = Log::Log4perl::get_logger($Class);
  $Self->{Logger}->debug("Creating instance of $Class");
  $Self->_init(@_);

  return $Self;
}

# ------------------------------------------------------------------------
# method: _init (private)
#
# Initialisation of the object. Do not call directly.
# ------------------------------------------------------------------------
sub _init {
    my $Self = shift; 

    # in case of inheritance
    # Call the parent initialization first
    $Self->TestTools::MyParent::_init(@_);

    my %attr = @_;

    # Attribute initialization
    $Self->{\'scalar\'}  = 0;
    $Self->{\'listRef\'} = [];
    $Self->{\'hashRef\'} = [];

    # Takes the constructor parameters as object attributs
    foreach my $key ( keys %attr ) {
        $Self->{$key} = $attr{$key};
    }

    # Others initialisation
}

';


# ------------------------------------------------------------------------
# method: usage
#
#  Display how to call this script and exit.
# ------------------------------------------------------------------------
sub usage {
    my $Self = shift;

    my $name = TestTools::Script::name();
    print $help;
    my $parameters = "\[filenames\]*";

    print "usage: perl $name \[options\] $parameters\n";
    print STDERR TestTools::Conf::ScriptConfig::GetOnlineHelp();
    exit();
}

# ------------------------------------------------------------------------
# method: ownedComment
#
# Extract the body of the ownedOperation of an XML element
#
# Parameter:
#     $parent - the parent element of the ownedComment
# ------------------------------------------------------------------------
sub ownedComment {
    my ( $Self, $parent ) = @_;

    my $comment  = "";
    my @comments = $parent->children('ownedComment[@xmi:type="uml:Comment"]');
    foreach my $elt (@comments) {

        # elt is a ownedComment
        $comment .= $elt->att('body');
    }
    return $comment;
}

# ------------------------------------------------------------------------
# method: ancestor
#
# Look for a class ancestor of an XML class
#
# Parameter:
#     $elt - the parent element of the generalization
#
# Return: A compound string separated by '::' or undef
# ------------------------------------------------------------------------
sub ancestor {
    my ( $Self, $elt ) = @_;

    my $gen = $elt->first_descendant('generalization[@xmi:type="uml:Generalization"]');

    if ( defined($gen) ) {
        return $Self->{'fullname'}->{$gen->att('general')};
    }
    else {
        return undef;
    }
}

# ------------------------------------------------------------------------
# method: parent
#
# Look for a class immediat parent
#
# Parameter:
#     $elt - the parent element of the generalization
#
# Return: s string or undef      
# ------------------------------------------------------------------------
sub parent {
    my ( $Self, $elt ) = @_;

    my $gen = $elt->first_descendant('generalization[@xmi:type="uml:Generalization"]');

    if ( defined($gen) ) {
        my @ancestor = split ('::', $Self->{'fullname'}->{$gen->att('general')});
        my $parent = pop (@ancestor);
    }
    else {
        return undef;
    }
}

# ------------------------------------------------------------------------
# method: stereotype
#
# Extract the stereotype of an element
#
# Parameter:
#     $parent - the parent element of the stereotype
#
# Return: a string, 'accessor' by exemple
# ------------------------------------------------------------------------
sub stereotype {
    my ( $Self, $parent ) = @_;

    my $ext = $parent->first_descendant('xmi:Extension[@extender="Bouml"]');

    if ( defined($ext) ) {
        my $stereo = $ext->first_descendant('stereotype');
        return $stereo->att('name');
    }
    else {
        return undef;
    }
}

# ------------------------------------------------------------------------
# routine: printLine
#
# print a line of dash in a file descriptor. Used to format the output.
# ------------------------------------------------------------------------
sub printLine {

    my $fd = shift;

    print $fd "# ", '-' x 76, "\n";
}

# ------------------------------------------------------------------------
# method: treatClass
#
# Extract data from one class and generate the perl module.
#
# Parameter:
#     model - XML model element
#     package - XML package element
#     class - XML class element
# ------------------------------------------------------------------------
sub treatClass {

    my ( $Self, $model, $package, $class ) = @_;

    my $packageComment = $Self->ownedComment($package);
    my $classComment   = $Self->ownedComment($class);
    my $date           = `date`;
    chomp($date);
    my $author = `whoami`;
    chomp($author);

    my $dirName = $package->att('name');
    my $name        = $class->att('name');
    my @nameList    = split ("::", $name);
    my $shortName   = $nameList[@nameList - 1];
    my $id          = $class->att('xmi:id');
    my $filename    = $dirName . "/" . $shortName . ".pm";
    my $version     = "1.0";
    my $ancestor    = $Self->ancestor($class);
    my $parent      = $Self->parent($class);
    my $fullname    = ($ancestor) ? $ancestor . "::" . $name : $name;
    my $parentPackage;
    if ($parent) {
        $parentPackage = join ('::', (split('\/', $targetDir), $dirName, $Self->parent($class)));
    } 
    my $packageName = join ('::', (split('\/', $targetDir), $dirName, $name));
    
    # print "\n# Title: Class ", $name, ", id=$id", "\n";
    # print "fullname=", $fullname, "\n";

    $Self->{'fullname'}->{$id} = $fullname;

    open( FD, "> $filename" ) || die("can't open $filename: $!");

    printLine(*FD);
    print FD "#\n";
    print FD "# Title: Class ", $name, "\n";
    print FD "#\n";
    print FD "# File - $targetDir/$filename\n";
    print FD "# Version - $version\n";
    # commented out because it makes diff harder
    # print FD "# Date - $date\n";
    print FD "# Author - $author\n";
    print FD "#\n";
    print FD "# Name:\n";
    print FD "#\n";
    print FD "#    package $name\n";
    print FD "#\n";
    print FD "# Abstract:\n";
    print FD "#\n";
    print FD "#    ", join( "\n#    ", split( /\n/, $classComment ) ), "\n";
    print FD "#\n";
    printLine(*FD);

    my $decl = "
use strict;
use vars qw(\$VERSION \@ISA \@EXPORT \@EXPORT_OK);

use Exporter;
use Log::Log4perl;
use Data::Dumper;
";

    if ($ancestor) {
        print FD "package $packageName;\n";
        print FD $decl;
        print FD "use $parentPackage;\n";
        print FD "\n\$VERSION = 1;\n";
        print FD "\n\@ISA = qw($parent);\n";
    } else {
        print FD "package $name;\n";
        print FD $decl;
        print FD "\n\$VERSION = 1;\n";        
        print FD "\n\@ISA = qw(Exporter);\n";

        print FD $constructor;
    }

    # for each method (operation)
    foreach
      my $op ( $class->children('ownedOperation[@xmi:type="uml:Operation"]') )
    {
        my $name       = $op->att('name');
        my $comment    = $Self->ownedComment($op);
        my $abstract   = $op->att('isAbstract');     # "true" or "false"
        my $stereotype = $Self->stereotype($op);

        if ($stereotype) {
            print "stereotype = ", $Self->stereotype($op), "\n"
              if ( defined( $Self->stereotype($op) ) );
        }

        # print method header
        print FD "\n";
        printLine(*FD);
        print FD "# method: $name\n";
        print FD "#\n";
        print FD "#    ", join( "\n#    ", split( /\n/, $comment ) ), "\n";

        my @params = $op->children('ownedParameter[@xmi:type="uml:Parameter"]');
        my @paramsName = ('Self');
        foreach my $param (@params) {
            push( @paramsName, $param->att('name') );
        }

        printLine(*FD);

        print FD "sub $name {\n";
        print FD "    my (\$", join( ", \$", @paramsName ), ") = \@_;\n";

        if ( $abstract eq "true" ) {
            print FD
"    die \"Method $name is abstract. This instance should never be called.\";\n";
        } elsif ($stereotype) {
            if ( $Self->stereotype($op) eq "accessor" ) {
                    
                print FD "\n    # accessor\n";
                print FD "    \$Self->{'$name'} = shift if \@_;\n";
                print FD "    return \$Self->{'$name'};\n";
            }
        }
        print FD "}\n";
    }

    unless ($ancestor) {
        print FD $dumper;
    }
    print FD "\n1;\n";
    close(FD);
}

# ------------------------------------------------------------------------
# method: treatPackage
#
# Extract data from one package. Generate the associated Perl modules.
#
# Parameter:
#     parent - XML classes parent element
# ------------------------------------------------------------------------
sub treatPackage {

    my ( $Self, $model, $package ) = @_;

    foreach
      my $class ( $package->children('packagedElement[@xmi:type="uml:Class"]') )
    {
        $Self->treatClass( $model, $package, $class );
    }

    # Generates package documentation
    my $filename = $package->att('name') . "/" . $package->att('name') . ".txt";
    my $packageComment = $Self->ownedComment($package);
    
    # Create the directory if it does not exist
    unless (-d $package->att('name')) {
        mkdir $package->att('name');
    }

    open( FD, "> $filename" ) || die("can't open $filename: $!");
    print FD $packageComment, "\n";
    close FD;
}

# ------------------------------------------------------------------------
# method: extractPackages
#
# Extract data from packages
#
# Parameter:
#     parent - XML classes parent element
# ------------------------------------------------------------------------
sub extractPackages {

    my ( $Self, $model ) = @_;

    # for all the packages in the model
    my @subs = $model->children('packagedElement[@xmi:type="uml:Package"]');
    foreach my $pack (@subs) {

        # elt is a packagedElement
        $Self->treatPackage( $model, $pack );
    }
}

# ------------------------------------------------------------------------
# method: parse
#
# Parse an BoUML XMI file.
#
# Parameters:
#     filename : name of the file to parse
# ------------------------------------------------------------------------
sub parse {

    my ( $Self, $filename ) = @_;

    $twig->parsefile($filename);
    my $root = $twig->root;

    my $model = $root->first_child('uml:Model');

    # $Self->extractInheritance($model);
    $Self->extractPackages($model);

    # $twig->print();
}

# ------------------------------------------------------------------------
# method: run
#
#  Scrip main method.
# ------------------------------------------------------------------------
sub run {
    my $Self = shift;

    my $name = TestTools::Script::basename();
    $Self->info("starting $name");

    # for all the files specified on CLI
    foreach my $arg (@ARGV) {
        $Self->info("cli param: $arg");
        while ( glob($arg) ) {
            $Self->info("cli sub-param: $_");
            if ( -f $_ ) {
                $Self->info( "file: " . $_ );
                $Self->parse($_);
            } else {
                warn "file $_ not found";
            }
            if ( -d $_ ) { $Self->info( "directory: " . $_ ) }
        }
    }
    $Self->info("$name is completed");
}

# ------------------------------------------------------------------------
# ------------------------------------------------------------------------
# read CLI and configuration file
my @argv = @ARGV;
TestTools::Conf::ScriptConfig::Initialize(TestTools::Script::configurationFilename(),
    \%OptionSet, TestTools::Script::optionSet());

# initilize logger configuration
main::setOutputDirectory (TestTools::Conf::ScriptConfig::GetOption('outputDirectory'));

my $script = new XMI2Perl();
$script->run(argv => @argv);

