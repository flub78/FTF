<!-- Documentation produced by the Html generator of Bouml (http://bouml.free.fr) -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Class Protocol::Type</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body bgcolor="#ffffff">

<div class = "title">Class Protocol::Type</div>
<p></p>

<!-- ============================================================= -->

<a name="refclass128298"></a>
<p>#    In this context a type has various attributes; size, number and structure of sub-components, etc.<br />#<br />#    Root class for the protocol management layer in this context a type has <br />#    various attributes; size, number and structure of sub-components, etc. <br />#    This class will be derived for various scalar types and lists and records.<br />#    <br />#    Types must contain enough information to control encoding or decoding <br />#    of messages. They can be used directly but are likely <br />#    generated by the parsing of a formal protocol specification. Once<br />#    the types database generated for a protocol, the databse is used either<br />#    directly by a script or to generate encoding or decoding routine<br />#    in a code generation phase.<br />#<br />#    This class is really the corner stone of this job. The main idea is really<br />#    to encapsulate the types layout inside this data. It is a purely<br />#    declarative task, and then to not have to worry any more about the physical<br />#    structure of the data.<br />#<br />#    This job is the third implementation after two succesful ones (the Ada<br />#    message generator and the Tcl Protocol handling layer)<br />#<br />#    The point is really about binary buffer parsing and generation. The purpose <br />#    of this job is to fill the gap between the binary buffer structure <br />#    specification and the most convenient API to handle data compliant with<br />#    this structure. The Tcl approach was really <br />#    succesful. The parser error reporting was not perfect and there was no <br />#    code generation but these two points could have been improved, so it <br />#    is possible to just port this design. However I wonder if alternative <br />#    approach like binary regular expressions pattern matching could not be as<br />#    effective. <br />#<br /># Section: Types and Messages versus classes and objects<br />#<br />#       The point of this development is really to encapsulate all knowledge<br />#       about the protocol format into some program database AND NOT INTO<br />#       a class hierarchy structure.<br />#       For exemple if you have a Date record made of a Year, Month and Day fields<br />#       you need something to contain the date definition.<br />#       Something that we have often done and that I would avoid, at<br />#       least without automated code generation, is to derive a Date class<br />#       from the record class and to define the field list for the Date. The only <br />#       difference between the record class and the date class is that the record class<br />#       is able to handle any record and the date class only date records.<br />#       The reason for which I would avoid the approach is that it generates<br />#       thousand of lines of code that you have to maintain even for relatively <br />#       simple protocols (you generate on class for each message type).<br />#<br /># Types naming:<br />#<br />#       Types are identified by a name. Eventually it can be a complex <br />#       structured name if we want to support name spaces. So the type<br />#       constructor will take this name as input parameter and the class<br />#       will maintain a mechanism to retreive a reference to the object<br />#       from the name. I think that the most currently used convention<br />#       to build structure names is to use '::' double colomns as <br />#       sepearators. So we will use that, but in fact names are just<br />#       strings so you can use whatever convention that you want.<br />#<br /># Section: Encode and Decode profile<br />#<br />#       The input parameter of an encode method is either<br />#       - a scalar for scalar types<br />#       - a reference to a list for list types<br />#       - a reference to a hash for record types.<br />#<br />#       The result of a decode routine is a message from the Message class. Messages are objects<br />#       with a filed named value which has the same semantic than the encode input parameter.<br />#       Others fields are used to keep information about the decoding success, error number and error<br />#       messages, sizes, etc.<br />#<br />#       At some point during implementation I used Messages as well as input parameters, but it generates<br />#       an over-head that it is difficult to justify. Perhaps that I could have two versions of encode ??<br />#<br /># Section: Error Management Policiy<br />#<br />#       It seams resonable to treat in different ways encoding and decoding errors. During<br />#       encoding you are supposed to know what you are doing and you should provide data<br />#       compatible to the type that you are using. So errors are treated by exception.<br />#<br />#       During decoding it is more natural to sometime attempt to decode invalid data. So I have currently <br />#       decided to store errors and error description inside the returned messages. That way decoding code<br />#       shoudl never raise exceptions, exception remains exceptional (this probably comes from my<br />#       former Ada programer life). It implies that usser must check the error status before to use<br />#       a message. It has also the advantage that partial values can be stored in messages. For example<br />#       when you detect an error while parsing the end of the message, you can have already stored<br />#       in the message the first fields. That may help to build more meaningful error messages.<br />#<br /># Truncation or error: <br />#<br />#       I have to decide what to do when more data than required is supplied for encoding. For example<br />#       20 bytes are supplied to fit into a 16 bytes string. FIrst I'll treat that as an error, just to<br />#       be safe. I'll relax the control if it makes the usage more difficult.<br />#      <br /><br /></p><p>Declaration :</p><ul><li>Python : class Protocol::Type(object)</li></ul><p>Directly inherited by : <a href="class128938.html#refclass128938"><b>Protocol::List</b></a> <a href="class129066.html#refclass129066"><b>Protocol::Record</b></a> <a href="class128426.html#refclass128426"><b>Protocol::ScalarType</b></a> <a href="class129450.html#refclass129450"><b>Protocol::TLV_Alternative</b></a> <a href="class129322.html#refclass129322"><b>Protocol::TLV_List</b></a> <a href="class130602.html#refclass130602"><b>Protocol::TLV_Message</b></a> </p>
<div class="sub">
<a name="refoperation130474"></a>
<table><tr><td><div class="element">Operation <b>declare</b></div></td></tr></table><p>#   Alias for new. When you do not care for the returned object and intend<br />#   to rely on access to type by name (usage of Encode and Decocde). The<br />#   dclare routine makes the code mode natural. You just declare new types.<br /><br /></p><p>Declaration :</p><ul><li>Uml : + declare() : </li><li>Python : def declare()</li></ul><a name="refoperation129578"></a>
<table><tr><td><div class="element">Operation <b>encode</b></div></td></tr></table><p># Encode a value or a list of values according to the type. This method<br /># is virtual and each type implementation will have to provide one.<br />#<br /># Return: a binary buffer<br /><br /></p><p>Declaration :</p><ul><li>Uml : abstract, + encode() : </li><li>Python : @abstractmethod<br />def encode()</li></ul><a name="refoperation129706"></a>
<table><tr><td><div class="element">Operation <b>decode</b></div></td></tr></table><p># Decode a binary buffer and return a message. This method<br /># is virtual and each type implementation will have to provide one.<br /><br /></p><p>Declaration :</p><ul><li>Uml : abstract, + decode() : </li><li>Python : @abstractmethod<br />def decode()</li></ul><a name="refoperation129834"></a>
<table><tr><td><div class="element">Operation <b>Encode</b></div></td></tr></table><p># Encode using a type name. The Type class maintain a table of all the<br /># existing types by name. It is possible to use the method to encode<br /># a list of value without having access to a type object.<br />#<br /># Return: a binary buffer<br /></p><p>Declaration :</p><ul><li>Uml : static, + Encode() : </li><li>Python : @staticmethod<br />def Encode()</li></ul><a name="refoperation129962"></a>
<table><tr><td><div class="element">Operation <b>Decode</b></div></td></tr></table><p># Decode a binary buffer and return a message using the type name<br /># instead of having direct access to the object.<br /><br /></p><p>Declaration :</p><ul><li>Uml : static, + Decode() : </li><li>Python : @staticmethod<br />def Decode()</li></ul><a name="refoperation130090"></a>
<table><tr><td><div class="element">Operation <b>TypeList</b></div></td></tr></table><p># Return the list of non anonymous types<br /></p><p>Declaration :</p><ul><li>Uml : static, + TypeList() : </li><li>Python : @staticmethod<br />def TypeList()</li></ul><a name="refoperation130218"></a>
<table><tr><td><div class="element">Operation <b>DefinedType</b></div></td></tr></table><p># Return true when the type has already been defined<br /><br /></p><p>Declaration :</p><ul><li>Uml : static, + DefinedType() : </li><li>Python : @staticmethod<br />def DefinedType()</li></ul><a name="refoperation130346"></a>
<table><tr><td><div class="element">Operation <b>TypeFromName</b></div></td></tr></table><p># Return a type from its name<br /><br /></p><p>Declaration :</p><ul><li>Uml : static, + TypeFromName() : </li><li>Python : @staticmethod<br />def TypeFromName()</li></ul><a name="refoperation130602"></a>
<table><tr><td><div class="element">Operation <b>size</b></div></td></tr></table><p># Sets or returns the size of the type in bytes. The size is undef when the type<br /># is unbounded or contain unbounded elements. It has beed considered than bytes<br /># are more convenients than bits for sizes. Eventually some methods to extract<br /># bitfields from byte streams will be provided.<br /><br /></p><p>Declaration :</p><ul><li>Uml : + size() : </li><li>Python : def size()</li></ul><a name="refrelation129322"></a>
<table><tr><td><div class="element">Relation <b>&lt;association&gt;</b></div></td></tr></table><p>Declaration :</p><ul><li>Uml : -  : <a href="class128042.html#refclass128042"><b>Message</b></a></li><li>Python : self. = None<br /></li></ul></div>
<p>All public operations : <a href="class128298.html#refoperation130474"><b>declare</b></a> , <a href="class128298.html#refoperation129706"><b>decode</b></a> , <a href="class128298.html#refoperation129962"><b>Decode</b></a> , <a href="class128298.html#refoperation130218"><b>DefinedType</b></a> , <a href="class128298.html#refoperation129834"><b>Encode</b></a> , <a href="class128298.html#refoperation129578"><b>encode</b></a> , <a href="class128298.html#refoperation130602"><b>size</b></a> , <a href="class128298.html#refoperation130346"><b>TypeFromName</b></a> , <a href="class128298.html#refoperation130090"><b>TypeList</b></a> </p>
</body>
</html>
